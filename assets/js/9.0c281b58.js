(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{429:function(t,a,s){"use strict";s.r(a);var r=s(65),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"重构之心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重构之心"}},[t._v("#")]),t._v(" 重构之心")]),t._v(" "),s("blockquote",[s("p",[t._v("营地应该要比你来时，更干净。")])]),t._v(" "),s("p",[t._v("身处开发团队中，无论是新人还是老手，我认为重构之心应该一直保持。当然也不是呼吁大家天天重构。重构虽然是一种好习惯，但也是因地制宜。我们为什么需要重构代码？是提升技术能力？还是加快代码书写速度？又或者单纯只是因为这份代码不是出自你手，觉得别人的代码充斥着腐败不堪的味道？以上种种问题可能驱使着你重构现有代码，但是记住不要盲目给自己提供兴奋剂。通俗点说，不应该盲目的去重构，有时候太过于“勤劳”也是原罪！")]),t._v(" "),s("h2",{attrs:{id:"护林者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#护林者"}},[t._v("#")]),t._v(" 护林者")]),t._v(" "),s("p",[t._v("辛勤劳作的人当然是值得称赞和鼓励的，但并非任何时候你所做的都能被人称赞和嘉奖，有时可能都是徒劳。当你正在维护一个私有项目的时候，无论语种、无论大小、无论繁简，此时此刻你就是这片“领地”的“护林者”。换而言之，此时此刻应该没有人比你更懂这片“森林”，无论是直径小路、还是艰险泥泞，你都应该是了如指掌。当你需要肩负“护林者”职责的时候，就应该去这片林子里将那些图谋不轨的“人”赶出去，将那些阻挡了上山人去路的灌木移开，将那些容易伤人肌肤的荆棘劈断。提前预警“森林”中的黑暗境地，让前来这里冒险的人小心行事。")]),t._v(" "),s("h2",{attrs:{id:"安慰注释的陷阱"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安慰注释的陷阱"}},[t._v("#")]),t._v(" 安慰注释的陷阱")]),t._v(" "),s("p",[t._v("在《代码简洁之道》这本书中提到过注释也是一种让代码不干净的元素之一，但也说过必要的注释也是应该的。其实这并不矛盾，当你为你的代码书写注释时，我相信大部分情况肯定是为了将来自己读这一块时不迷路。“即便最后还是会迷路，但也总比光秃秃的要好吧”，你会在心里自我安慰。诚然我自己也是如此，但是这样就陷入了“安慰注释”的陷阱。你认为无论自己的代码如何书写都不重要，你认为一行注释在未来可以为你指路，甚至可以帮助到其他冒险家。但老兄你知道吗，铺平道路不放路牌和草草定钉拿几块破板子往哪一甩，然后假惺惺的在上面写到：“此处通往 xxx，我已经为您铺平了道路，祝您顺利”之类的提示语。我相信你作为软件工程师，一定是希望自己是前者。如果你不在意这些细节，可以无需往下去阅读。因为你的傲慢和不负责会让你未来尝尽苦头，并且被人在背后不断抱怨你留下来的烂摊子。")]),t._v(" "),s("h2",{attrs:{id:"请做好-指路牌"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请做好-指路牌"}},[t._v("#")]),t._v(" 请做好“指路牌”")]),t._v(" "),s("p",[t._v("试想一下，你在写下你业务代码第一行时，是不是等同于留下了“线索”。我将自己编写的代码大到类命名，小到变量命名，我都称之为“线索”，因为后面的冒险者会寻迹而来。如果你做好了整体的道路规划和良好的注释习惯，我相信冒险家们一定会感叹“真是不错的设计”！那么何为不错的设计？这个问题没有统一答案。但是能够确定的是，语义化和共鸣性无论用在变量名，还是方法名，他都是非常不错的做法，这能够让人阅读时不那么晕头转向。可以夸张的说，如果做好了以上工作，即使你不写一行注释，冒险家也能闻着“花香”到达终点。但为了能让整个阅读流程变得轻松愉悦，适当制作好指路牌，也是“可选”加分项。好的注释应该是简洁明了的，而不是罗里吧嗦像个唐僧不断念经。")]),t._v(" "),s("h2",{attrs:{id:"哦-天呐-上帝造的变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哦-天呐-上帝造的变量"}},[t._v("#")]),t._v(" 哦，天呐！上帝造的变量！")]),t._v(" "),s("p",[t._v("我相信，在你日常书写代码的时候，经常能听到有开发抱怨说:“该死，又是魔法值。”这样的声音。对于一个软件开发工程师来说，是常有的事。那么什么是“魔法值”呢?简单的说，就是你正在拜读前任同事的代码，突然看到一个 if(flag=5)之类的代码行。这里的 5 就是魔法值，它需要你结合代码上下文去推断它的作用。如此，不仅加大了维护难度和时间成本，还容易让人感到愤怒与不适。那么，我们如何改造魔法值呢？其实可以用“枚举”或者将其定义为“常量”。无论前者、后者，他都能有效避免后来者一头雾水的局面。相信我，你不会喜欢有人在你面前施展魔法的，即便他的做法是那么华丽，但还是会出乱子。")]),t._v(" "),s("h2",{attrs:{id:"控制变量领土"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制变量领土"}},[t._v("#")]),t._v(" 控制变量领土")]),t._v(" "),s("p",[t._v("古代权臣当拥有了绝对权力后，他就敢凌驾皇权之上。换言之，在代码中有一个变量可以嚣张到，控制多个作用域的正常运行流程，那么相信我他绝对是 blacksheep(害群之马)。你应该早早端了他的老窝，让他横尸遍野，啊不对，应该是死无葬身之地。大部分的软件工程师对于全局变量都是嗤之以鼻的，甚至是恐惧。你试想一下，全局变量就好比多米诺骨牌，系统中某些方法对其可以任意“抽拉”，并且你还不知道是哪个混蛋方法开了第一枪。这时候你只能苦苦调试断点，美好的一天就这么过去了。女友的饭局你也去不了，美好的约会就此破碎。所以请你干掉这个轻浮的家伙（跟谁都搭讪，跟谁都随意）。")])])}),[],!1,null,null,null);a.default=e.exports}}]);